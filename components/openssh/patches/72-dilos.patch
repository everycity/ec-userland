Index: openssh-6.6p1/auth.h
===================================================================
--- openssh-6.6p1/auth.h.orig
+++ openssh-6.6p1/auth.h
@@ -75,6 +75,7 @@ struct Authctxt {
 #endif
 	Buffer		*loginmsg;
 	void		*methoddata;
+	int		chanid;
 };
 /*
  * Every authentication method has to handle authentication requests for
Index: openssh-6.6p1/channels.c
===================================================================
--- openssh-6.6p1/channels.c.orig
+++ openssh-6.6p1/channels.c
@@ -270,7 +270,8 @@ channel_register_fds(Channel *c, int rfd
  */
 Channel *
 channel_new(char *ctype, int type, int rfd, int wfd, int efd,
-    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock)
+    u_int window, u_int maxpack, int extusage, char *remote_name, int nonblock,
+    int local_tun, int ip_fd)
 {
 	int found;
 	u_int i;
@@ -314,6 +315,8 @@ channel_new(char *ctype, int type, int r
 	c->ostate = CHAN_OUTPUT_OPEN;
 	c->istate = CHAN_INPUT_OPEN;
 	c->flags = 0;
+	c->local_tun = local_tun;
+	c->ip_fd = ip_fd;
 	channel_register_fds(c, rfd, wfd, efd, extusage, nonblock, 0);
 	c->notbefore = 0;
 	c->self = found;
@@ -343,7 +346,7 @@ channel_new(char *ctype, int type, int r
 	c->mux_pause = 0;
 	c->delayed = 1;		/* prevent call to channel_post handler */
 	TAILQ_INIT(&c->status_confirms);
-	debug("channel %d: new [%s]", found, remote_name);
+	debug("%s: channel %d: new [%s]", __func__, found, remote_name);
 	return c;
 }
 
@@ -365,6 +368,8 @@ channel_find_maxfd(void)
 	return max;
 }
 
+extern void sys_tun_delete(int, int, int);
+
 int
 channel_close_fd(int *fdp)
 {
@@ -387,6 +392,11 @@ channel_close_fds(Channel *c)
 	channel_close_fd(&c->rfd);
 	channel_close_fd(&c->wfd);
 	channel_close_fd(&c->efd);
+#if defined(SSH_TUN_ILLUMOS)
+	debug("%s: request delete ip_fd for tun%d", __func__, c->local_tun);
+	if (c->local_tun >= 0)
+		sys_tun_delete(c->local_tun, SSH_TUNMODE_POINTOPOINT, c->ip_fd);
+#endif
 }
 
 /* Free the channel and close its fd/socket. */
@@ -1261,7 +1271,7 @@ channel_connect_stdio_fwd(const char *ho
 
 	c = channel_new("stdio-forward", SSH_CHANNEL_OPENING, in, out,
 	    -1, CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,
-	    0, "stdio-forward", /*nonblock*/0);
+	    0, "stdio-forward", /*nonblock*/0, -1, -1);
 
 	c->path = xstrdup(host_to_connect);
 	c->host_port = port_to_connect;
@@ -1356,7 +1366,7 @@ channel_post_x11_listener(Channel *c, fd
 
 		nc = channel_new("accepted x11 socket",
 		    SSH_CHANNEL_OPENING, newsock, newsock, -1,
-		    c->local_window_max, c->local_maxpacket, 0, buf, 1);
+		    c->local_window_max, c->local_maxpacket, 0, buf, 1, -1, -1);
 		if (compat20) {
 			packet_start(SSH2_MSG_CHANNEL_OPEN);
 			packet_put_cstring("x11");
@@ -1500,7 +1510,7 @@ channel_post_port_listener(Channel *c, f
 		}
 		set_nodelay(newsock);
 		nc = channel_new(rtype, nextstate, newsock, newsock, -1,
-		    c->local_window_max, c->local_maxpacket, 0, rtype, 1);
+		    c->local_window_max, c->local_maxpacket, 0, rtype, 1, -1, -1);
 		nc->listening_port = c->listening_port;
 		nc->host_port = c->host_port;
 		if (c->path != NULL)
@@ -1537,7 +1547,7 @@ channel_post_auth_listener(Channel *c, f
 		nc = channel_new("accepted auth socket",
 		    SSH_CHANNEL_OPENING, newsock, newsock, -1,
 		    c->local_window_max, c->local_maxpacket,
-		    0, "accepted auth socket", 1);
+		    0, "accepted auth socket", 1, -1, -1);
 		if (compat20) {
 			packet_start(SSH2_MSG_CHANNEL_OPEN);
 			packet_put_cstring("auth-agent@openssh.com");
@@ -1665,7 +1675,7 @@ channel_handle_rfd(Channel *c, fd_set *r
 static int
 channel_handle_wfd(Channel *c, fd_set *readset, fd_set *writeset)
 {
-	struct termios tio;
+	/*struct termios tio;*/
 	u_char *data = NULL, *buf;
 	u_int dlen, olen = 0;
 	int len;
@@ -1953,7 +1963,7 @@ channel_post_mux_listener(Channel *c, fd
 	}
 	nc = channel_new("multiplex client", SSH_CHANNEL_MUX_CLIENT,
 	    newsock, newsock, -1, c->local_window_max,
-	    c->local_maxpacket, 0, "mux-control", 1);
+	    c->local_maxpacket, 0, "mux-control", 1, -1, -1);
 	nc->mux_rcb = c->mux_rcb;
 	debug3("%s: new mux channel %d fd %d", __func__,
 	    nc->self, nc->sock);
@@ -2866,7 +2876,7 @@ channel_setup_fwd_listener(int type, con
 		/* Allocate a channel number for the socket. */
 		c = channel_new("port listener", type, sock, sock, -1,
 		    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,
-		    0, "port listener", 1);
+		    0, "port listener", 1, -1, -1);
 		c->path = xstrdup(host);
 		c->host_port = port_to_connect;
 		c->listening_addr = addr == NULL ? NULL : xstrdup(addr);
@@ -3001,7 +3001,7 @@ channel_setup_fwd_listener_streamlocal(i
 	/* Allocate a channel number for the socket. */
 	c = channel_new("unix listener", type, sock, sock, -1,
 	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,
-	    0, "unix listener", 1);
+	    0, "unix listener", 1, -1, -1);
 	c->path = xstrdup(path);
 	c->host_port = port;
 	c->listening_port = PORT_STREAMLOCAL;
@@ -3343,7 +3353,7 @@ connect_to(const char *host, u_short por
 		return NULL;
 	}
 	c = channel_new(ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,
-	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);
+	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1, -1, -1);
 	c->connect_ctx = cctx;
 	return c;
 }
@@ -3517,7 +3527,7 @@ x11_create_display_inet(int x11_display_
 		nc = channel_new("x11 listener",
 		    SSH_CHANNEL_X11_LISTENER, sock, sock, -1,
 		    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,
-		    0, "X11 inet listener", 1);
+		    0, "X11 inet listener", 1, -1, -1);
 		nc->single_connection = single_connection;
 		(*chanids)[n] = nc->self;
 	}
@@ -3693,7 +3703,7 @@ x11_input_open(int type, u_int32_t seq,
 		/* Allocate a channel for this connection. */
 		c = channel_new("connected x11 socket",
 		    SSH_CHANNEL_X11_OPEN, sock, sock, -1, 0, 0, 0,
-		    remote_host, 1);
+		    remote_host, 1, -1, -1);
 		c->remote_id = remote_id;
 		c->force_drain = 1;
 	}
Index: openssh-6.6p1/channels.h
===================================================================
--- openssh-6.6p1/channels.h.orig
+++ openssh-6.6p1/channels.h
@@ -160,6 +160,8 @@ struct Channel {
 	mux_callback_fn		*mux_rcb;
 	void			*mux_ctx;
 	int			mux_pause;
+	int			local_tun; /* tun id if it available, -1 for others*/
+	int			ip_fd; /* need only for ILLUMOS */
 };
 
 #define CHAN_EXTENDED_IGNORE		0
@@ -208,7 +210,7 @@ struct Channel {
 
 Channel	*channel_by_id(int);
 Channel	*channel_lookup(int);
-Channel *channel_new(char *, int, int, int, int, u_int, u_int, int, char *, int);
+Channel *channel_new(char *, int, int, int, int, u_int, u_int, int, char *, int, int, int);
 void	 channel_set_fds(int, int, int, int, int, int, int, u_int);
 void	 channel_free(Channel *);
 void	 channel_free_all(void);
Index: openssh-6.6p1/clientloop.c
===================================================================
--- openssh-6.6p1/clientloop.c.orig
+++ openssh-6.6p1/clientloop.c
@@ -85,6 +85,9 @@
 #include <termios.h>
 #include <pwd.h>
 #include <unistd.h>
+#if defined(SSH_TUN_ILLUMOS)
+#include <sys/fcntl.h>
+#endif
 
 #include "openbsd-compat/sys-queue.h"
 #include "xmalloc.h"
@@ -1834,7 +1837,7 @@ client_input_agent_open(int type, u_int3
 	 */
 	if (sock >= 0) {
 		c = channel_new("", SSH_CHANNEL_OPEN, sock, sock,
-		    -1, 0, 0, 0, "authentication agent connection", 1);
+		    -1, 0, 0, 0, "authentication agent connection", 1, -1, -1);
 		c->remote_id = remote_id;
 		c->force_drain = 1;
 	}
@@ -1913,7 +1916,7 @@ client_request_x11(const char *request_t
 		return NULL;
 	c = channel_new("x11",
 	    SSH_CHANNEL_X11_OPEN, sock, sock, -1,
-	    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0, "x11", 1);
+	    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0, "x11", 1, -1, -1);
 	c->force_drain = 1;
 	return c;
 }
@@ -1936,7 +1939,7 @@ client_request_agent(const char *request
 	c = channel_new("authentication agent connection",
 	    SSH_CHANNEL_OPEN, sock, sock, -1,
 	    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0,
-	    "authentication agent connection", 1);
+	    "authentication agent connection", 1, -1, -1);
 	c->force_drain = 1;
 	return c;
 }
@@ -1957,14 +1960,22 @@ client_request_tun_fwd(int tun_mode, int
 
 	debug("Requesting tun unit %d in mode %d", local_tun, tun_mode);
 
+	int ip_fd = -1;
+#if defined(SSH_TUN_ILLUMOS)
+	if ((ip_fd = open("/dev/udp", O_RDWR)) < 0) {
+		debug("%s: ip_fd (%d) open failed: %s", __func__, ip_fd,
+		    strerror(errno));
+		return -1;
+	}
+#endif
 	/* Open local tunnel device */
-	if ((fd = tun_open(local_tun, tun_mode)) == -1) {
+	if ((fd = tun_open(local_tun, tun_mode, ip_fd)) == -1) {
 		error("Tunnel device open failed.");
 		return -1;
 	}
 
 	c = channel_new("tun", SSH_CHANNEL_OPENING, fd, fd, -1,
-	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1);
+	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1, local_tun, ip_fd);
 	c->datagram = 1;
 
 #if defined(SSH_TUN_FILTER)
Index: openssh-6.6p1/misc.c
===================================================================
--- openssh-6.6p1/misc.c.orig
+++ openssh-6.6p1/misc.c
@@ -711,10 +711,10 @@ secure_permissions(struct stat *st, uid_
 }
 
 int
-tun_open(int tun, int mode)
+tun_open(int tun, int mode, int ip_fd)
 {
 #if defined(CUSTOM_SYS_TUN_OPEN)
-	return (sys_tun_open(tun, mode));
+	return (sys_tun_open(tun, mode, ip_fd));
 #elif defined(SSH_TUN_OPENBSD)
 	struct ifreq ifr;
 	char name[100];
Index: openssh-6.6p1/misc.h
===================================================================
--- openssh-6.6p1/misc.h.orig
+++ openssh-6.6p1/misc.h
@@ -55,7 +55,7 @@ void	 replacearg(arglist *, u_int, char
 	     __attribute__((format(printf, 3, 4)));
 void	 freeargs(arglist *);
 
-int	 tun_open(int, int);
+int	 tun_open(int, int, int);
 
 /* Common definitions for ssh tunnel device forwarding */
 #define SSH_TUNMODE_NO		0x00
Index: openssh-6.6p1/mux.c
===================================================================
--- openssh-6.6p1/mux.c.orig
+++ openssh-6.6p1/mux.c
@@ -447,7 +447,7 @@ process_mux_new_session(u_int rid, Chann
 
 	nc = channel_new("session", SSH_CHANNEL_OPENING,
 	    new_fd[0], new_fd[1], new_fd[2], window, packetmax,
-	    CHAN_EXTENDED_WRITE, "client-session", /*nonblock*/0);
+	    CHAN_EXTENDED_WRITE, "client-session", /*nonblock*/0, -1, -1);
 
 	nc->ctl_chan = c->self;		/* link session -> control channel */
 	c->remote_id = nc->self; 	/* link control -> session channel */
@@ -1222,7 +1222,7 @@ muxserver_listen(void)
 	mux_listener_channel = channel_new("mux listener",
 	    SSH_CHANNEL_MUX_LISTENER, muxserver_sock, muxserver_sock, -1,
 	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,
-	    0, options.control_path, 1);
+	    0, options.control_path, 1, -1, -1);
 	mux_listener_channel->mux_rcb = mux_master_read_cb;
 	debug3("%s: mux listener channel %d fd %d", __func__,
 	    mux_listener_channel->self, mux_listener_channel->sock);
Index: openssh-6.6p1/openbsd-compat/port-tun.c
===================================================================
--- openssh-6.6p1/openbsd-compat/port-tun.c.orig
+++ openssh-6.6p1/openbsd-compat/port-tun.c
@@ -55,7 +55,7 @@
 #include <linux/if_tun.h>
 
 int
-sys_tun_open(int tun, int mode)
+sys_tun_open(int tun, int mode, int ip_fd)
 {
 	struct ifreq ifr;
 	int fd = -1;
@@ -106,6 +106,233 @@ sys_tun_open(int tun, int mode)
 }
 #endif /* SSH_TUN_LINUX */
 
+#if defined(SSH_TUN_ILLUMOS)
+#include <net/if.h>
+#include <sys/sockio.h>
+#include <sys/stropts.h>
+#include <net/if_tun.h>
+
+#define IP_NODE "/dev/udp"
+#define NODE_LEN 30
+
+int
+sys_tun_open(int ppa, int mode, int ip_fd)
+{
+	struct lifreq ifr;
+	struct strioctl  strioc, strioc_if;
+	int newppa = 0;
+	char name[100];
+	int fd = -1;
+	int if_fd = -1;
+	int arp_fd = -1;
+	int ip_muxid = 0;
+	int arp_muxid = 0;
+	const char *tunbase = "tun";
+	char tunname[NODE_LEN];
+
+	if (mode == SSH_TUNMODE_ETHERNET) {
+#ifdef SSH_TUN_NO_L2
+		debug("%s: no layer 2 tunnelling support", __func__);
+		return (-1);
+#else
+		tunbase = "tap";
+#endif
+	}
+
+	/* Open the tunnel device */
+	if (ppa == SSH_TUNID_ANY) {
+		for (ppa = 0; ppa <= SSH_TUNID_MAX; ppa++) {
+			snprintf(name, sizeof(name), "/dev/ipnet/%s%d",
+			    tunbase, ppa);
+			if ((fd = open(name, O_RDWR)) >= 0) {
+				continue;
+			} else {
+				close(fd);
+				break;
+			}
+		}
+	}
+	if (ppa > SSH_TUNID_MAX) {
+		debug("%s: invalid tunnel %s%d", __func__, tunbase, ppa);
+		return (-1);
+	}
+
+	snprintf(tunname, sizeof(tunname), "%s%d", tunbase, ppa);
+	snprintf(name, sizeof(name), "/dev/%s", tunbase);
+	if ((fd = open(name, O_RDWR)) < 0) {
+		debug("%s: fd (%d) open failed: %s", __func__, if_fd,
+		    strerror(errno));
+		goto failed;
+	}
+
+	memset(&ifr, 0, sizeof(struct lifreq));
+
+	/* Assign a new PPA and get its unit number. */
+	strioc.ic_cmd = TUNNEWPPA;
+	strioc.ic_timout = 0;
+	strioc.ic_len = sizeof(ppa);
+	strioc.ic_dp = (char *)&ppa;
+	if ((newppa = ioctl (fd, I_STR, &strioc)) < 0){
+		debug("%s: (1) Can't create %s, newppa=%d, ppa:%d", __func__, name, newppa, ppa);
+		goto failed;
+        }
+
+	if(newppa != ppa){
+		debug("%s: (2) Can't create %s, newppa=%d, ppa=%d", __func__, name, newppa, ppa);
+		goto failed;
+	}
+
+	if ((if_fd = open (name, O_RDWR, 0)) < 0) {
+		debug("%s: (3) Can't open %sd", __func__, name);
+		goto failed;
+	}
+
+	/* push ip module to the stream */
+	if (ioctl(if_fd, I_PUSH, "ip") < 0) {
+		debug("%s: Can't push ip module to %s device", __func__, name);
+		goto failed;
+	}
+
+	if(mode != SSH_TUNMODE_ETHERNET) /* TUN */
+	{
+    		/* set unit number to the device */
+    		if (ioctl (if_fd, IF_UNITSEL, (char *) &ppa) < 0) {
+			debug("%s: Can't set unit number to %s device", __func__, name);
+			goto failed;
+    		}
+	}
+
+	if(mode == SSH_TUNMODE_ETHERNET) /* TAP */
+	{
+    		if (ioctl(if_fd, SIOCGLIFFLAGS, &ifr) < 0) {
+			debug("%s: Can't get flags (1)", __func__);
+			goto failed;
+    		}
+		strncpy (ifr.lifr_name, name, sizeof (ifr.lifr_name));
+    		ifr.lifr_ppa = ppa;
+    		/* assign ppa according to the unit number returned by tun device */
+    		if (ioctl (if_fd, SIOCSLIFNAME, &ifr) < 0) {
+			debug("%s: Can't set PPA %d", __func__, ppa);
+			goto failed;
+    		}
+    		if (ioctl(if_fd, SIOCGLIFFLAGS, &ifr) < 0) {
+			debug("%s: Can't get flags (2)", __func__);
+			goto failed;
+    		}
+
+    		/* push arp module to the device stream */
+    		if (ioctl(if_fd, I_PUSH, "arp") < 0) {
+			debug("%s: Can't push ARP module to device stream", __func__);
+			goto failed;
+    		}
+
+    		/* push arp module to the ip stream */
+    		if (ioctl(ip_fd, I_PUSH, "arp") < 0) {
+			debug("%s: Can't push ARP module to ip stream", __func__);
+			goto failed;
+    		}
+
+    		/* open arp fd */
+    		if((arp_fd = open(name, O_RDWR)) < 0){
+			debug("%s: Can't open '%s'", __func__, name);
+			goto failed;
+    		}
+    		/* push arp module to the stream */
+    		if (ioctl(arp_fd, I_PUSH, "arp") < 0) {
+			debug("%s: Can't push ARP module to arp stream", __func__);
+			goto failed;
+    		}
+
+    		/* set ifname to arp */
+    		strioc_if.ic_cmd = SIOCSLIFNAME;
+    		strioc_if.ic_timout = 0;
+    		strioc_if.ic_len = sizeof(ifr);
+    		strioc_if.ic_dp = (char *)&ifr;
+		/* set interface name to arp stream */
+    		if (ioctl(arp_fd, I_STR, &strioc_if) < 0){
+			debug("%s: Can't set ifname to arp stream", __func__);
+			goto failed;
+    		}
+	}
+
+	/* link interface stream to ip stream */
+	if ((ip_muxid = ioctl (ip_fd, I_PLINK, if_fd)) < 0){
+		debug("%s: Can't link %s device to ip", __func__, name);
+		goto failed;
+	}
+
+	if(mode == SSH_TUNMODE_ETHERNET) {
+    		if ((arp_muxid = ioctl (ip_fd, I_PLINK, arp_fd)) < 0){
+			debug("%s: Can't link %s device to ARP", __func__, name);
+			goto failed;
+    		}
+	}
+
+	memset((void *)&ifr, 0x0, sizeof(struct lifreq));
+	strncpy (ifr.lifr_name, tunname, sizeof (ifr.lifr_name));
+	ifr.lifr_ip_muxid  = ip_muxid;
+	ifr.lifr_arp_muxid  = 0;
+	if(mode == SSH_TUNMODE_ETHERNET) {
+    		ifr.lifr_arp_muxid  = arp_muxid;
+	}
+	if (ioctl (ip_fd, SIOCSLIFMUXID, &ifr) < 0){
+		if(mode == SSH_TUNMODE_ETHERNET) {
+			ioctl (ip_fd, I_PUNLINK, arp_muxid);
+		}
+		ioctl (ip_fd, I_PUNLINK, ip_muxid);
+		debug("%s: Can't set muxid of  %s device, ip_muxid=%d", __func__, name, ip_muxid);
+		goto failed;
+	}
+	return (fd);
+
+failed:
+	if (arp_fd >= 0)
+		close(arp_fd);
+	if (if_fd >= 0)
+		close(if_fd);
+	if (fd >= 0)
+		close(fd);
+	return (-1);
+}
+
+void
+sys_tun_delete(int ppa, int mode, int ip_fd)
+{
+	int arp_muxid = 0, ip_muxid = 0;
+	struct lifreq ifr;
+	char tunname[NODE_LEN];
+
+	snprintf(tunname, sizeof(tunname), "tun%d", ppa);
+
+	memset((void *)&ifr, 0x0, sizeof(struct lifreq));
+	strncpy (ifr.lifr_name, tunname, sizeof (ifr.lifr_name));
+
+	if (ioctl (ip_fd, SIOCGLIFFLAGS, &ifr) < 0){
+		debug("%s: (failed) Can't get flag", __func__);
+		return;
+	}
+
+	if (ioctl (ip_fd, SIOCGLIFMUXID, &ifr) < 0){
+		debug("%s: (failed) Can't get muxid", __func__);
+		return;
+	}
+
+	if(mode == SSH_TUNMODE_ETHERNET) {
+    		/* just in case, unlink arp's stream */
+    		arp_muxid = ifr.lifr_arp_muxid;
+    		if (ioctl (ip_fd, I_PUNLINK, arp_muxid) < 0){
+        	/* ignore err */
+    		}
+	}
+
+	ip_muxid = ifr.lifr_ip_muxid;
+	if (ioctl (ip_fd, I_PUNLINK, ip_muxid) < 0){
+		debug("%s: (failed) Can't unlink interface", __func__);
+		return;
+	}
+}
+#endif /* SSH_TUN_ILLUMOS */
+
 #ifdef SSH_TUN_FREEBSD
 #include <sys/socket.h>
 #include <net/if.h>
@@ -115,7 +342,7 @@ sys_tun_open(int tun, int mode)
 #endif
 
 int
-sys_tun_open(int tun, int mode)
+sys_tun_open(int tun, int mode, int ip_fd)
 {
 	struct ifreq ifr;
 	char name[100];
Index: openssh-6.6p1/openbsd-compat/port-tun.h
===================================================================
--- openssh-6.6p1/openbsd-compat/port-tun.h.orig
+++ openssh-6.6p1/openbsd-compat/port-tun.h
@@ -19,9 +19,9 @@
 
 struct Channel;
 
-#if defined(SSH_TUN_LINUX) || defined(SSH_TUN_FREEBSD)
+#if defined(SSH_TUN_LINUX) || defined(SSH_TUN_FREEBSD) || defined(SSH_TUN_ILLUMOS)
 # define CUSTOM_SYS_TUN_OPEN
-int	  sys_tun_open(int, int);
+int	  sys_tun_open(int, int, int);
 #endif
 
 #if defined(SSH_TUN_COMPAT_AF) || defined(SSH_TUN_PREPEND_AF)
Index: openssh-6.6p1/serverloop.c
===================================================================
--- openssh-6.6p1/serverloop.c.orig
+++ openssh-6.6p1/serverloop.c
@@ -55,6 +55,9 @@
 #include <termios.h>
 #include <unistd.h>
 #include <stdarg.h>
+#if defined(SSH_TUN_ILLUMOS)
+#include <sys/fcntl.h>
+#endif
 
 #include "openbsd-compat/sys-queue.h"
 #include "xmalloc.h"
@@ -1012,11 +1015,19 @@ server_request_tun(void)
 			goto done;
 		tun = forced_tun_device;
 	}
-	sock = tun_open(tun, mode);
+	int ip_fd = -1;
+#if defined(SSH_TUN_ILLUMOS)
+	if ((ip_fd = open("/dev/udp", O_RDWR)) < 0) {
+		debug("%s: ip_fd (%d) open failed: %s", __func__, ip_fd,
+		    strerror(errno));
+		return -1;
+	}
+#endif
+	sock = tun_open(tun, mode, ip_fd);
 	if (sock < 0)
 		goto done;
 	c = channel_new("tun", SSH_CHANNEL_OPEN, sock, sock, -1,
-	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1);
+	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1, tun, ip_fd);
 	c->datagram = 1;
 #if defined(SSH_TUN_FILTER)
 	if (mode == SSH_TUNMODE_POINTOPOINT)
@@ -1051,7 +1062,7 @@ server_request_session(void)
 	 */
 	c = channel_new("session", SSH_CHANNEL_LARVAL,
 	    -1, -1, -1, /*window size*/0, CHAN_SES_PACKET_DEFAULT,
-	    0, "server-session", 1);
+	    0, "server-session", 1, -1, -1);
 	if (session_open(the_authctxt, c->self) != 1) {
 		debug("session open failed, free channel %d", c->self);
 		channel_free(c);
Index: openssh-6.6p1/session.c
===================================================================
--- openssh-6.6p1/session.c.orig
+++ openssh-6.6p1/session.c
@@ -241,7 +241,7 @@ auth_input_request_forwarding(struct pas
 	nc = channel_new("auth socket",
 	    SSH_CHANNEL_AUTH_SOCKET, sock, sock, -1,
 	    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,
-	    0, "auth socket", 1);
+	    0, "auth socket", 1, -1, -1);
 	nc->path = xstrdup(auth_sock_name);
 	return 1;
 
@@ -2005,6 +2005,7 @@ session_open(Authctxt *authctxt, int cha
 		fatal("no user for session %d", s->self);
 	debug("session_open: session %d: link with channel %d", s->self, chanid);
 	s->chanid = chanid;
+	authctxt->chanid = chanid;
 	return 1;
 }
 
Index: openssh-6.6p1/ssh.c
===================================================================
--- openssh-6.6p1/ssh.c.orig
+++ openssh-6.6p1/ssh.c
@@ -1640,7 +1640,7 @@ ssh_session2_open(void)
 	c = channel_new(
 	    "session", SSH_CHANNEL_OPENING, in, out, err,
 	    window, packetmax, CHAN_EXTENDED_WRITE,
-	    "client-session", /*nonblock*/0);
+	    "client-session", /*nonblock*/0, -1, -1);
 
 	debug3("ssh_session2_open: channel_new: %d", c->self);
 
Index: openssh-6.6p1/sshd.c
===================================================================
--- openssh-6.6p1/sshd.c.orig
+++ openssh-6.6p1/sshd.c
@@ -2625,6 +2625,8 @@ do_ssh2_kex(void)
 	debug("KEX done");
 }
 
+extern void sys_tun_delete(int, int, int);
+
 /* server specific fatal cleanup */
 void
 cleanup_exit(int i)
@@ -2638,6 +2640,13 @@ cleanup_exit(int i)
 				error("%s: kill(%d): %s", __func__,
 				    pmonitor->m_pid, strerror(errno));
 		}
+#if defined(SSH_TUN_ILLUMOS)
+		Channel *c = channel_lookup(the_authctxt->chanid);
+		debug("%s: request delete ip_fd with tun%d, permit_tun:%d", __func__,
+			c->local_tun, options.permit_tun);
+		if (c->local_tun >= 0)
+			sys_tun_delete(c->local_tun, SSH_TUNMODE_POINTOPOINT, c->ip_fd);
+#endif
 	}
 #ifdef SSH_AUDIT_EVENTS
 	/* done after do_cleanup so it can cancel the PAM auth 'thread' */
