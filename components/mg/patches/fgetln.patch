--- mg-20110120/fgetln.c.~1~	2008-12-30 12:41:23.000000000 +0000
+++ mg-20110120/fgetln.c	2011-08-05 14:18:38.091799011 +0100
@@ -22,22 +22,73 @@
  * fgetln() wrapper for operating systems with getline()
  */
 
-#define _GNU_SOURCE		/* for getline() */
-#include <sys/types.h>
 #include <stdio.h>
-#include <string.h>
 
-#if defined (__GLIBC__) || defined (__CYGWIN__)  /* FreeWRT: only build
-						      this where needed */
-char *fgetln(FILE *, size_t *);
+#define INITIAL_LINE_LENGTH	256
+
+extern	char *fgetln(register FILE *,size_t *);
+extern	char *getline(register FILE *);
+
+#if defined (_WINDOWS) || defined (_WIN32) || defined (linux) || defined (sun)
+
+#include <stdlib.h>
 
 char *
-fgetln(FILE *stream, size_t *len)
+fgetln(fp, lenp)
+	register FILE *fp;
+	size_t *lenp;
 {
-	char *lb = NULL;
-	size_t lbsz = 0;
+	char c;
+	size_t n, siz;
+	size_t len, new_len;
+	char *buf;
+	char *p;
+
+	len = INITIAL_LINE_LENGTH;
+	n = siz = 0;
+
+	if ((buf = malloc(INITIAL_LINE_LENGTH + 1)) == NULL)
+		return (NULL);
+
+	p = buf;
+	for (;;) {
+		if ((c = getc(fp)) == EOF) {
+			if (siz != 0)
+				break;
+			free(buf);
+			return (NULL);
+		}
+
+		++siz;
 
-	*len = getline(&lb, &lbsz, stream);
-	return ((*len == (size_t)-1) ? NULL : lb);
+		if (c == '\n') {
+			*p++ = c;
+			break;
+		}
+		if (n++ >= len) {
+			new_len = len << 1;
+			if ((buf = realloc(buf, new_len + 1)) == NULL)
+	                        return (NULL);
+			len = new_len;
+			p = buf;
+	                p += len >> 1;
+		}
+		*p++ = c;
+	}
+	*p = 0;
+	if (lenp != NULL)
+		*lenp = siz;
+	return (buf);
 }
+#elif defined (BSD)
+extern	char *fgetln(register FILE *,size_t *);
 #endif
+
+char *
+getline(fp)
+	register FILE *fp;
+{
+
+	return (fgetln(fp, NULL));
+}
+
